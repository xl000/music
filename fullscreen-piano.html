<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>全屏钢琴</title>

    <!-- CSS文件 -->
    <style>
        /* 加载页面样式 */
        #loadingPage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .loading-content {
            text-align: center;
            color: white;
            max-width: 400px;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .loading-content h2 {
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .progress-container {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 1.2em;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .loading-details {
            font-size: 0.9em;
            opacity: 0.8;
        }

        /* 主容器初始隐藏 */
        .container {
            display: none;
        }

        .fullscreen-piano {
            display: none;
        }
    </style>
    <link rel="stylesheet" href="css/fullscreen-piano.css">
</head>

<body>
    <!-- 加载界面 -->
    <div id="loadingPage">
        <div class="loading-content">
            <h2>正在加载音源...</h2>
            <div class="progress-container">
                <div class="progress-bar" id="globalProgressBar"></div>
            </div>
            <div class="progress-text" id="progressText">0%</div>
            <div class="loading-details" id="loadingDetails">准备加载...</div>
        </div>
    </div>
    <div class="container">
        <h1>全屏钢琴 - 特效点播</h1>
        <div class="description" id="conversionInfo">
            准备播放转换后的序列...
        </div>
        <button class="btn" id="showPianoBtn">打开全屏钢琴</button>
        <div class="footer">
            全屏钢琴 | 基于 pure-piano.js
        </div>
    </div>

    <!-- 全屏钢琴容器 -->
    <div id="fullscreenPiano" class="fullscreen-piano">
        <div class="fullscreen-piano-header">
            <button id="collapsePiano" class="collapse-btn">收起钢琴</button>
        </div>
        <div class="fullscreen-piano-content">
            <div class="fullscreen-playback-info" id="fullscreenPlaybackInfo">
                准备播放...
            </div>
            <div class="fullscreen-piano-container">
                <div class="fullscreen-piano-keyboard-container">
                    <div class="fullscreen-piano-keyboard" id="fullscreenPianoKeyboard"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 引入Tone.js库 -->
    <script src="js/Tone.js"></script>
    <script>
        const octaveStart = 0; // 从A0开始
        const octaveEnd = 8;   // 到C8结束
        const blackKeys = ["C#", "D#", "F#", "G#", "A#"];
        let noteDuration = 0.8;

        // 音源配置 - 与ear.html相同
        const soundFiles = {
            "A0": "A0.mp3",
            "C1": "C1.mp3",
            "A1": "A1.mp3",
            "C2": "C2.mp3",
            "A2": "A2.mp3",
            "C3": "C3.mp3",
            "A3": "A3.mp3",
            "C4": "C4.mp3",
            "A4": "A4.mp3",
            "C5": "C5.mp3",
            "A5": "A5.mp3",
            "C6": "C6.mp3",
            "A6": "A6.mp3",
            "A7": "A7.mp3",
            "C7": "C7.mp3",
            "C8": "C8.mp3"
        };

        // 加载进度控制
        let loadProgress = 0;
        let isAudioLoaded = false;
        let globalSampler = null; // 全局采样器变量

        // 更新加载进度
        function updateLoadProgress(percent, message) {
            loadProgress = Math.min(100, Math.max(0, percent));

            const progressBar = document.getElementById('globalProgressBar');
            const progressText = document.getElementById('progressText');
            const loadingDetails = document.getElementById('loadingDetails');

            if (progressBar) {
                progressBar.style.width = loadProgress + '%';
            }
            if (progressText) {
                progressText.textContent = Math.round(loadProgress) + '%';
            }
            if (loadingDetails) {
                loadingDetails.textContent = message;
            }
        }

        // 模拟加载进度（用于正常加载时）
        function simulateLoadProgress() {
            let progress = 0;
            const interval = setInterval(() => {
                if (isAudioLoaded) {
                    clearInterval(interval);
                    return;
                }

                progress += Math.random() * 5;
                if (progress < 90) {
                    updateLoadProgress(progress, `正在加载音源文件... (${Math.round(progress)}%)`);
                } else if (progress < 99) {
                    updateLoadProgress(progress, "即将完成...");
                }
            }, 200);
        }

        // 隐藏加载界面
        function hideLoadingPage() {
            const loadingPage = document.getElementById('loadingPage');
            if (loadingPage) {
                // 添加淡出效果
                loadingPage.style.opacity = '0';
                loadingPage.style.transition = 'opacity 0.5s ease';

                setTimeout(() => {
                    loadingPage.style.display = 'none';
                    // 显示主内容
                    document.querySelector('.container').style.display = 'block';
                }, 500);
            }
        }

        // 显示加载界面
        function showLoadingPage() {
            const loadingPage = document.getElementById('loadingPage');
            if (loadingPage) {
                loadingPage.style.display = 'flex';
                loadingPage.style.opacity = '1';
            }
        }

        // 初始化音源加载 - 优先使用sessionStorage缓存
        function initAudioLoad() {
            return new Promise((resolve, reject) => {
                // 先检查sessionStorage中是否有缓存的音源数据
                const cachedAudioData = sessionStorage.getItem('pianoAudioData');
                const cachedLoadTime = sessionStorage.getItem('pianoAudioLoadTime');

                // 如果缓存存在且是最近加载的（比如1小时内），直接使用缓存
                if (cachedAudioData && cachedLoadTime && (Date.now() - parseInt(cachedLoadTime)) < 3600000) {
                    try {
                        console.log("从sessionStorage加载缓存的音源数据");
                        updateLoadProgress(50, "从缓存加载音源配置...");

                        const audioData = JSON.parse(cachedAudioData);

                        globalSampler = new Tone.Sampler({
                            urls: audioData.soundFiles,
                            baseUrl: audioData.baseUrl,
                            onload: () => {
                                console.log("从缓存加载音源完成");
                                updateLoadProgress(100, "音源加载完成！");
                                isAudioLoaded = true;

                                // 延迟隐藏加载界面，让用户看到完成信息
                                setTimeout(() => {
                                    hideLoadingPage();
                                    resolve(globalSampler);
                                }, 500);
                            },
                            onerror: (error) => {
                                console.error("缓存音源加载失败，重新加载:", error);
                                updateLoadProgress(0, "缓存加载失败，重新加载...");
                                // 缓存加载失败，使用正常加载流程
                                loadAudioFromScratch(resolve, reject);
                            }
                        }).toDestination();

                        return;
                    } catch (error) {
                        console.error("缓存解析失败，重新加载音源:", error);
                        updateLoadProgress(0, "缓存解析失败，重新加载...");
                        // 如果缓存解析失败，继续正常加载流程
                        loadAudioFromScratch(resolve, reject);
                    }
                } else {
                    // 没有缓存，正常加载
                    updateLoadProgress(0, "开始加载音源...");
                    loadAudioFromScratch(resolve, reject);
                }
            });
        }

        // 正常加载音源的函数
        function loadAudioFromScratch(resolve, reject) {
            console.log("开始加载音源...");

            // 开始模拟加载进度
            simulateLoadProgress();

            globalSampler = new Tone.Sampler({
                urls: soundFiles,
                baseUrl: "./sounds/",
                onload: () => {
                    console.log("本地钢琴音源加载完成");
                    updateLoadProgress(100, "音源加载完成！");
                    isAudioLoaded = true;

                    // 将音源数据存储到sessionStorage供下次使用
                    try {
                        const audioData = {
                            soundFiles: soundFiles,
                            baseUrl: "./sounds/",
                            loadTime: Date.now()
                        };
                        sessionStorage.setItem('pianoAudioData', JSON.stringify(audioData));
                        sessionStorage.setItem('pianoAudioLoadTime', Date.now().toString());
                        console.log("音源数据已存储到sessionStorage");
                    } catch (error) {
                        console.warn("sessionStorage存储失败:", error);
                    }

                    // 延迟隐藏加载界面，让用户看到完成信息
                    setTimeout(() => {
                        hideLoadingPage();
                        resolve(globalSampler);
                    }, 500);
                },
                onerror: (error) => {
                    console.error("音源加载错误:", error);
                    updateLoadProgress(0, `加载错误: ${error.message}`);
                }
            }).toDestination();
        }

        // 检查音频是否已加载
        function isAudioReady() {
            return isAudioLoaded;
        }

        // 获取采样器
        function getSampler() {
            if (!isAudioLoaded) {
                throw new Error("音频尚未加载完成");
            }
            return globalSampler;
        }

        // 创建钢琴键盘
        function createPiano(pianoElement) {
            if (!pianoElement) return;

            pianoElement.innerHTML = '';

            for (let octave = octaveStart; octave <= octaveEnd; octave++) {
                let startIndex = 0;
                let endIndex = 11;

                if (octave === 0) {
                    startIndex = 9;
                    endIndex = 11;
                } else if (octave === 8) {
                    startIndex = 0;
                    endIndex = 0;
                }

                const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

                for (let i = startIndex; i <= endIndex; i++) {
                    const note = notes[i];
                    const fullNote = note + octave;
                    const isBlack = blackKeys.includes(note);

                    const key = document.createElement('div');
                    key.className = `key ${isBlack ? 'black' : 'white'}`;
                    key.dataset.note = fullNote;

                    const label = document.createElement('div');
                    label.className = 'key-label';
                    label.textContent = fullNote;
                    key.appendChild(label);

                    // 点击琴键事件
                    key.addEventListener('click', async () => {
                        try {
                            if (!isAudioReady()) {
                                console.warn("音频尚未加载完成");
                                return;
                            }

                            if (Tone.context.state !== 'running') {
                                await Tone.start();
                            }

                            key.classList.add('playing');
                            setTimeout(() => key.classList.remove('playing'), 300);
                            getSampler().triggerAttackRelease(fullNote, noteDuration);
                        } catch (error) {
                            console.error("播放错误:", error);
                        }
                    });

                    // 触摸事件支持
                    key.addEventListener('touchstart', async (e) => {
                        e.preventDefault();
                        try {
                            if (!isAudioReady()) {
                                console.warn("音频尚未加载完成");
                                return;
                            }

                            if (Tone.context.state !== 'running') {
                                await Tone.start();
                            }

                            key.classList.add('playing');
                            setTimeout(() => key.classList.remove('playing'), 300);
                            getSampler().triggerAttackRelease(fullNote, noteDuration);
                        } catch (error) {
                            console.error("播放错误:", error);
                        }
                    });

                    pianoElement.appendChild(key);
                }
            }
        }

        // 播放钢琴音符
        async function playNote(noteName, duration = 0.8, startTime = null) {
            try {
                if (!isAudioReady()) {
                    console.warn("音频未加载，无法播放");
                    return;
                }

                await Tone.start();

                const now = startTime || Tone.now();
                getSampler().triggerAttackRelease(noteName, duration, now);

                // 高亮琴键
                const key = document.querySelector(`.fullscreen-piano-keyboard .key[data-note="${noteName}"]`);
                if (key) {
                    key.classList.add('playing');
                    setTimeout(() => {
                        key.classList.remove('playing');
                    }, duration * 1000);
                }

            } catch (error) {
                console.error("播放音符错误:", error);
            }
        }

        // 钢琴播放器
        class PianoPlayer {
            constructor() {
                this.isPlaying = false;
                this.currentTimeIndex = 0;
                this.playbackSchedule = null;
                this.scheduledEvents = [];
                this.pausedTime = 0;
                this.isPaused = false;
                this.isFullscreen = false;
                this.rainContainer = null;
                this.activeRainElements = [];
                this.noteBaseDuration = 1;
                this.noteBaseVelocity = 1;
                this.rainDefaultSpeed = 3;

                // 钢琴雨颜色映射
                this.baseNoteColors = {
                    'C4': 'hsl(0, 80%, 60%)',
                    'C#4': 'hsl(30, 80%, 60%)',
                    'D4': 'hsl(60, 80%, 60%)',
                    'D#4': 'hsl(90, 80%, 60%)',
                    'E4': 'hsl(120, 80%, 60%)',
                    'F4': 'hsl(150, 80%, 60%)',
                    'F#4': 'hsl(180, 80%, 60%)',
                    'G4': 'hsl(210, 80%, 60%)',
                    'G#4': 'hsl(240, 80%, 60%)',
                    'A4': 'hsl(270, 80%, 60%)',
                    'A#4': 'hsl(300, 80%, 60%)',
                    'B4': 'hsl(330, 80%, 60%)'
                };

                this.initUI();
                this.setupEventListeners();
            }

            initUI() {
                this.fullscreenPiano = document.getElementById('fullscreenPiano');
                this.fullscreenPianoKeyboard = document.getElementById('fullscreenPianoKeyboard');
                this.fullscreenPlaybackInfo = document.getElementById('fullscreenPlaybackInfo');
                this.collapseBtn = document.getElementById('collapsePiano');

                this.initPiano();
                this.createRainContainer();
            }

            setupEventListeners() {
                // 主页面按钮
                document.getElementById('showPianoBtn').addEventListener('click', () => this.showFullscreenPiano());

                // 收起按钮
                this.collapseBtn.addEventListener('click', () => this.collapseFullscreen());

                // 窗口大小改变时重新调整钢琴大小
                window.addEventListener('resize', () => {
                    if (this.isFullscreen) {
                        setTimeout(() => this.adjustPianoSize(), 100);
                    }
                });
            }

            createRainContainer() {
                this.rainContainer = document.createElement('div');
                this.rainContainer.className = 'piano-rain-container';
                this.fullscreenPiano.appendChild(this.rainContainer);
            }

            initPiano() {
                createPiano(this.fullscreenPianoKeyboard);
            }

            showFullscreenPiano() {
                this.isFullscreen = true;

                document.body.classList.add('fullscreen-mode');
                this.fullscreenPiano.classList.add('active');

                setTimeout(() => {
                    this.adjustPianoSize();
                }, 100);
            }

            collapseFullscreen() {
                this.isFullscreen = false;
                document.body.classList.remove('fullscreen-mode');
                this.fullscreenPiano.classList.remove('active');
                this.stopPlayback();
            }

            adjustPianoSize() {
                if (!this.isFullscreen) return;

                const keyboard = this.fullscreenPianoKeyboard;
                const container = keyboard.parentElement;
                const containerWidth = container.clientWidth;

                const whiteKeys = keyboard.querySelectorAll('.white.key');
                if (whiteKeys.length === 0) return;

                const totalWhiteKeys = whiteKeys.length;
                const newWhiteKeyWidth = Math.max(20, Math.floor(containerWidth / totalWhiteKeys));

                whiteKeys.forEach(key => {
                    key.style.width = `${newWhiteKeyWidth}px`;
                    key.style.minWidth = `${newWhiteKeyWidth}px`;
                });

                const blackKeys = keyboard.querySelectorAll('.black.key');
                const newBlackKeyWidth = Math.max(12, Math.floor(newWhiteKeyWidth * 0.6));

                blackKeys.forEach(key => {
                    key.style.width = `${newBlackKeyWidth}px`;
                    key.style.minWidth = `${newBlackKeyWidth}px`;
                    key.style.marginLeft = `-${newBlackKeyWidth / 2}px`;
                    key.style.marginRight = `-${newBlackKeyWidth / 2}px`;
                });

                const keyLabels = keyboard.querySelectorAll('.key-label');
                const newFontSize = Math.max(8, Math.floor(newWhiteKeyWidth * 0.4));
                keyLabels.forEach(label => {
                    label.style.fontSize = `${newFontSize}px`;
                });
            }

            // 播放单个音符
            async playPianoNote(noteName, duration = 0.8, startTime = null, velocity = 1) {
                try {
                    if (!isAudioReady()) {
                        console.warn("音频未加载，无法播放");
                        return;
                    }

                    let actualDuration = duration * this.noteBaseDuration;

                    await this.playNoteWithSampler(noteName, actualDuration, startTime, velocity);
                    this.highlightKey(noteName, actualDuration);

                    // 创建钢琴雨效果
                    this.createRainEffect(noteName, actualDuration);
                } catch (error) {
                    console.error("播放音符错误:", error);
                }
            }

            // 添加新的播放方法使用全局采样器
            async playNoteWithSampler(noteName, duration, startTime, velocity) {
                try {
                    if (Tone.context.state !== 'running') {
                        await Tone.start();
                    }

                    const normalizedVelocity = Math.max(0, Math.min(1, velocity / 127));
                    const actualStartTime = startTime || Tone.now();

                    getSampler().triggerAttackRelease(noteName, duration, actualStartTime, normalizedVelocity);
                } catch (error) {
                    console.error("播放音符错误:", error);
                    throw error;
                }
            }

            // 高亮琴键
            highlightKey(noteName, duration) {
                if (!this.fullscreenPianoKeyboard) return;

                const key = this.fullscreenPianoKeyboard.querySelector(`.key[data-note="${noteName}"]`);
                if (key) {
                    key.classList.add('playing');
                    setTimeout(() => {
                        key.classList.remove('playing');
                    }, duration * 1000);
                }
            }

            // 同时播放多个音符
            async playNotesSimultaneously(notes, startTime = null) {
                if (!notes || notes.length === 0) return;

                try {
                    if (Tone.context.state !== 'running') {
                        await Tone.start();
                    }

                    const actualStartTime = startTime || Tone.now() + 0.1;

                    const playPromises = notes.map(note => {
                        let duration = Math.min(note.duration || 0.8, 2);
                        const velocity = note.velocity || 1;

                        this.createRainEffect(note, duration, note);

                        return this.playPianoNote(note, duration, actualStartTime, velocity);
                    });

                    await Promise.all(playPromises);

                } catch (error) {
                    console.error("播放和弦错误:", error);
                }
            }

            getNoteColor(noteName) {
                const match = noteName.match(/([A-Ga-g]#?b?)(\d+)/);
                if (!match) return 'hsl(0, 80%, 60%)';

                const pitch = match[1];
                const octave = parseInt(match[2]);

                const baseNote = pitch + '4';
                const baseColor = this.baseNoteColors[baseNote] || 'hsl(0, 80%, 60%)';

                const hslMatch = baseColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (!hslMatch) return baseColor;

                const hue = parseInt(hslMatch[1]);
                const saturation = parseInt(hslMatch[2]);
                let lightness = parseInt(hslMatch[3]);

                const octaveDiff = octave - 4;
                lightness = Math.max(10, Math.min(90, lightness + (octaveDiff * 10)));

                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            }

            createRainEffect(noteName, duration, note) {
                if (!this.rainContainer || !this.fullscreenPianoKeyboard) return;

                const key = this.fullscreenPianoKeyboard.querySelector(`.key[data-note="${noteName}"]`);
                if (!key) return;

                const keyRect = key.getBoundingClientRect();
                const containerRect = this.fullscreenPiano.getBoundingClientRect();

                const rainElement = document.createElement('div');
                rainElement.className = 'piano-rain';

                const color = this.getNoteColor(noteName);

                const minHeight = 20;
                const maxHeight = 500;
                const baseHeight = duration * 100 * this.noteBaseDuration;
                const maxHeightValue = Math.min(maxHeight, Math.max(minHeight, baseHeight));

                const moveSpeed = this.rainDefaultSpeed * 100;

                const startTop = keyRect.top - containerRect.top;

                rainElement.style.cssText = `
                    position: absolute;
                    left: ${keyRect.left - containerRect.left}px;
                    top: ${startTop}px;
                    width: ${keyRect.width}px;
                    height: 0;
                    background: linear-gradient(to top, ${color}, ${color}00);
                    border-radius: 2px;
                    z-index: 5;
                    overflow: hidden;
                    transform-origin: bottom center;
                `;

                this.rainContainer.appendChild(rainElement);

                const rainData = {
                    element: rainElement,
                    note: note,
                    duration: duration,
                    startTime: Date.now(),
                    maxHeight: maxHeightValue,
                    moveSpeed: moveSpeed,
                    startTop: startTop,
                    containerHeight: containerRect.height,
                    keyRect: keyRect,
                    containerRect: containerRect,
                    isGrowing: true,
                    currentHeight: 0
                };

                this.activeRainElements.push(rainData);
                this.startRainMovement(rainData);
            }

            startRainMovement(rainData) {
                const startTime = Date.now();
                const growDuration = rainData.duration * 1000;

                const totalMoveDistance = rainData.containerHeight + rainData.maxHeight;
                const totalMoveTime = (totalMoveDistance / rainData.moveSpeed) * 1000;

                const animate = () => {
                    if (!rainData.element.parentNode) return;

                    const elapsed = Date.now() - startTime;

                    if (elapsed <= growDuration && rainData.isGrowing) {
                        const growProgress = elapsed / growDuration;
                        const currentHeight = growProgress * rainData.maxHeight;

                        rainData.element.style.height = `${currentHeight}px`;
                        rainData.element.style.top = `${rainData.startTop - currentHeight}px`;

                        rainData.currentHeight = currentHeight;

                    } else if (rainData.isGrowing) {
                        rainData.isGrowing = false;
                        rainData.growEndTime = Date.now();
                        rainData.finalHeight = rainData.currentHeight;
                        rainData.growEndTop = parseFloat(rainData.element.style.top) || rainData.startTop;
                    }

                    if (!rainData.isGrowing) {
                        const moveElapsed = Date.now() - rainData.growEndTime;
                        const moveDistance = (moveElapsed / 1000) * rainData.moveSpeed;

                        rainData.element.style.top = `${rainData.growEndTop - moveDistance}px`;
                        rainData.element.style.height = `${rainData.finalHeight}px`;
                    }

                    const currentTop = parseFloat(rainData.element.style.top) || rainData.startTop;
                    if (currentTop > -rainData.maxHeight && elapsed < (growDuration + totalMoveTime)) {
                        requestAnimationFrame(animate);
                    } else {
                        if (rainData.element.parentNode) {
                            rainData.element.parentNode.removeChild(rainData.element);
                        }
                        const index = this.activeRainElements.indexOf(rainData);
                        if (index > -1) {
                            this.activeRainElements.splice(index, 1);
                        }
                    }
                };

                requestAnimationFrame(animate);
            }

            clearRainEffects() {
                if (this.rainContainer) {
                    this.rainContainer.innerHTML = '';
                }
                this.activeRainElements = [];
            }

            clearKeyboardHighlights() {
                if (!this.fullscreenPianoKeyboard) return;
                const keys = this.fullscreenPianoKeyboard.querySelectorAll('.key.playing');
                keys.forEach(key => {
                    key.classList.remove('playing');
                });
            }

            // 播放序列（供外部调用）
            playSequence(sequence, title = "自定义序列") {
                if (!this.isFullscreen) {
                    this.showFullscreenPiano();
                    setTimeout(() => {
                        this.startPlayback(sequence, title);
                    }, 500);
                } else {
                    this.startPlayback(sequence, title);
                }
            }

            startPlayback(sequence, title) {
                if (this.isPlaying && !this.isPaused) return;

                if (this.isPaused) {
                    this.resumePlayback();
                    return;
                }

                this.isPlaying = true;
                this.isPaused = false;
                this.currentTimeIndex = 0;
                this.pausedTime = 0;

                if (this.playbackSchedule) {
                    this.playbackSchedule.stop();
                    this.playbackSchedule = null;
                }

                if (this.scheduledEvents.length) {
                    this.scheduledEvents.forEach(id => Tone.Transport.clear(id));
                    this.scheduledEvents = [];
                }

                this.clearRainEffects();
                this.clearKeyboardHighlights();

                // 按时间分组音符
                const timeGroups = this.groupNotesByTime(sequence);

                timeGroups.forEach((group, index) => {
                    const eventId = Tone.Transport.schedule((time) => {
                        if (!this.isPlaying) return;

                        if (group.notes.length > 1) {
                            // 播放和弦
                            this.playNotesSimultaneously(group.notes, time);
                        } else {
                            // 播放单音
                            this.playPianoNote(group.notes[0].note || group.notes[0],
                                group.duration || 0.8, time);
                        }

                        this.currentTimeIndex = index;
                        this.updatePlaybackInfo(index, timeGroups.length, title);

                    }, group.time);
                    this.scheduledEvents.push(eventId);
                });

                const totalDuration = sequence[sequence.length - 1].time +
                    (sequence[sequence.length - 1].duration || 0.8) + 0.5;
                const endEventId = Tone.Transport.schedule(() => {
                    this.stopPlayback();
                }, totalDuration);
                this.scheduledEvents.push(endEventId);

                Tone.Transport.start();
                this.playbackStartTime = Tone.now();
                this.updatePlaybackInfo(0, timeGroups.length, title);
            }

            // 按时间分组音符
            groupNotesByTime(notes) {
                if (notes.length === 0) return [];

                const validNotes = notes.filter(note => note && (note.time !== undefined || note.note));
                if (validNotes.length === 0) return [];

                // 为每个音符添加时间属性（如果不存在）
                validNotes.forEach((note, index) => {
                    if (note.time === undefined) {
                        note.time = index * 0.5; // 默认0.5秒间隔
                    }
                });

                // 按时间排序
                validNotes.sort((a, b) => (a.time || 0) - (b.time || 0));

                const groups = [];
                let currentGroup = {
                    time: validNotes[0].time,
                    notes: [validNotes[0]],
                    duration: validNotes[0].duration || 0.8
                };

                for (let i = 1; i < validNotes.length; i++) {
                    const note = validNotes[i];
                    if (!note) continue;

                    if (Math.abs(note.time - currentGroup.time) < 0.001) {
                        currentGroup.notes.push(note);
                        // 取最长的持续时间
                        if (note.duration && note.duration > currentGroup.duration) {
                            currentGroup.duration = note.duration;
                        }
                    } else {
                        groups.push(currentGroup);
                        currentGroup = {
                            time: note.time,
                            notes: [note],
                            duration: note.duration || 0.8
                        };
                    }
                }

                groups.push(currentGroup);
                return groups;
            }

            updatePlaybackInfo(currentIndex, totalItems, title) {
                this.fullscreenPlaybackInfo.textContent =
                    `播放中: ${title} (${currentIndex + 1}/${totalItems})`;
            }

            resumePlayback() {
                if (!this.isPaused) return;

                this.isPlaying = true;
                this.isPaused = false;
                Tone.Transport.start();
            }

            pausePlayback() {
                if (Tone.Transport.state === 'started') {
                    Tone.Transport.pause();
                    this.isPlaying = false;
                    this.isPaused = true;
                    this.pausedTime = Tone.Transport.seconds;

                    if (this.scheduledEvents.length) {
                        this.scheduledEvents.forEach(id => Tone.Transport.clear(id));
                        this.scheduledEvents = [];
                    }
                }
            }

            stopPlayback() {
                if (this.playbackSchedule) {
                    this.playbackSchedule.stop();
                    this.playbackSchedule = null;
                }

                Tone.Transport.stop();
                Tone.Transport.cancel();

                if (this.scheduledEvents.length) {
                    this.scheduledEvents.forEach(id => Tone.Transport.clear(id));
                    this.scheduledEvents = [];
                }

                this.isPlaying = false;
                this.isPaused = false;
                this.currentTimeIndex = 0;
                this.pausedTime = 0;
                this.clearKeyboardHighlights();
                this.clearRainEffects();

                this.fullscreenPlaybackInfo.textContent = `播放已停止`;
            }
        }

        // 初始化应用
        document.addEventListener('DOMContentLoaded', async function () {
            // 显示加载页面
            showLoadingPage();

            try {
                // 初始化音源加载
                await initAudioLoad();
                console.log("音源加载完成，开始初始化钢琴界面");

                // 初始化钢琴播放器
                window.pianoPlayer = new PianoPlayer();

                // 检查是否有转换序列需要播放
                checkAndPlayConvertedSequence();

            } catch (error) {
                console.error("初始化失败:", error);
                // 即使失败也继续显示界面
                hideLoadingPage();
                window.pianoPlayer = new PianoPlayer();
            }
        });

    </script>
</body>

</html>