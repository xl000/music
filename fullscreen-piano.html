<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨å±é’¢ç´</title>
    <!-- CSSæ–‡ä»¶ -->
    <link rel="stylesheet" href="css/fullscreen-piano.css">
    <style>
        /* åŠ è½½é¡µé¢æ ·å¼ */
        #loadingPage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .loading-content {
            text-align: center;
            color: white;
            max-width: 600px;
            padding: 20px;
        }

        .loading-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .loading-subtitle {
            font-size: 1.2rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .progress-container {
            width: 80%;
            max-width: 400px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 20px;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            width: 0%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 1.1rem;
            margin-top: 10px;
        }

        .loading-details {
            font-size: 0.9rem;
            margin-top: 10px;
            opacity: 0.8;
        }

        .loading-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        /* éšè—ä¸»å†…å®¹ç›´åˆ°åŠ è½½å®Œæˆ */
        .container, #fullscreenPiano {
            display: none;
        }
    </style>
</head>

<body>
    <!-- éŸ³æºåŠ è½½é¡µé¢ -->
    <div id="loadingPage">
        <div class="loading-content">
            <div class="loading-icon">ğŸ¹</div>
            <h1 class="loading-title">å…¨å±é’¢ç´</h1>
            <p class="loading-subtitle">æ­£åœ¨åŠ è½½é’¢ç´éŸ³æºï¼Œè¯·ç¨å€™...</p>
            
            <div class="progress-container">
                <div id="globalProgressBar" class="progress-bar"></div>
            </div>
            
            <div id="progressText" class="progress-text">0%</div>
            <div id="loadingDetails" class="loading-details">åˆå§‹åŒ–ä¸­...</div>
        </div>
    </div>

    <!-- ä¸»é¡µé¢å†…å®¹ -->
    <div class="container">
        <h1>å…¨å±é’¢ç´ - ç‰¹æ•ˆç‚¹æ’­</h1>
        <div class="description" id="conversionInfo">
            å‡†å¤‡æ’­æ”¾è½¬æ¢åçš„åºåˆ—...
        </div>
        <button class="btn" id="showPianoBtn">æ‰“å¼€å…¨å±é’¢ç´</button>
        <div class="footer">
            å…¨å±é’¢ç´ | åŸºäº pure-piano.js
        </div>
    </div>

    <!-- å…¨å±é’¢ç´å®¹å™¨ -->
    <div id="fullscreenPiano" class="fullscreen-piano">
        <div class="fullscreen-piano-header">
            <button id="collapsePiano" class="collapse-btn">æ”¶èµ·é’¢ç´</button>
        </div>
        <div class="fullscreen-piano-content">
            <div class="fullscreen-playback-info" id="fullscreenPlaybackInfo">
                å‡†å¤‡æ’­æ”¾...
            </div>
            <div class="fullscreen-piano-container">
                <div class="fullscreen-piano-keyboard-container">
                    <div class="fullscreen-piano-keyboard" id="fullscreenPianoKeyboard"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- å¼•å…¥Tone.jsåº“ -->
    <script src="js/Tone.js"></script>
    <script>
        // éŸ³æºæ–‡ä»¶æ˜ å°„
        const soundFiles = {
            "A0": "A0.mp3",
            "C1": "C1.mp3",
            "A1": "A1.mp3",
            "C2": "C2.mp3",
            "A2": "A2.mp3",
            "C3": "C3.mp3",
            "A3": "A3.mp3",
            "C4": "C4.mp3",
            "A4": "A4.mp3",
            "C5": "C5.mp3",
            "A5": "A5.mp3",
            "C6": "C6.mp3",
            "A6": "A6.mp3",
            "A7": "A7.mp3",
            "C7": "C7.mp3",
            "C8": "C8.mp3"
        };

        // åŠ è½½è¿›åº¦æ§åˆ¶
        let loadProgress = 0;
        let isAudioLoaded = false;
        let globalSampler = null;

        // æ›´æ–°åŠ è½½è¿›åº¦
        function updateLoadProgress(percent, message) {
            loadProgress = Math.min(100, Math.max(0, percent));
            
            const progressBar = document.getElementById('globalProgressBar');
            const progressText = document.getElementById('progressText');
            const loadingDetails = document.getElementById('loadingDetails');
            
            if (progressBar) {
                progressBar.style.width = loadProgress + '%';
            }
            if (progressText) {
                progressText.textContent = Math.round(loadProgress) + '%';
            }
            if (loadingDetails) {
                loadingDetails.textContent = message;
            }
        }

        // æ¨¡æ‹ŸåŠ è½½è¿›åº¦ï¼ˆç”¨äºæ­£å¸¸åŠ è½½æ—¶ï¼‰
        function simulateLoadProgress() {
            let progress = 0;
            const interval = setInterval(() => {
                if (isAudioLoaded) {
                    clearInterval(interval);
                    return;
                }
                
                progress += Math.random() * 5;
                if (progress < 90) {
                    updateLoadProgress(progress, `æ­£åœ¨åŠ è½½éŸ³æºæ–‡ä»¶... (${Math.round(progress)}%)`);
                } else if (progress < 99) {
                    updateLoadProgress(progress, "å³å°†å®Œæˆ...");
                }
            }, 200);
        }

        // éšè—åŠ è½½ç•Œé¢
        function hideLoadingPage() {
            const loadingPage = document.getElementById('loadingPage');
            if (loadingPage) {
                // æ·»åŠ æ·¡å‡ºæ•ˆæœ
                loadingPage.style.opacity = '0';
                loadingPage.style.transition = 'opacity 0.5s ease';
                
                setTimeout(() => {
                    loadingPage.style.display = 'none';
                    // æ˜¾ç¤ºä¸»å†…å®¹
                    document.querySelector('.container').style.display = 'block';
                }, 500);
            }
        }

        // åˆå§‹åŒ–éŸ³æºåŠ è½½ - ä¼˜å…ˆä½¿ç”¨sessionStorageç¼“å­˜
        function initAudioLoad() {
            return new Promise((resolve, reject) => {
                // å…ˆæ£€æŸ¥sessionStorageä¸­æ˜¯å¦æœ‰ç¼“å­˜çš„éŸ³æºæ•°æ®
                const cachedAudioData = sessionStorage.getItem('pianoAudioData');
                const cachedLoadTime = sessionStorage.getItem('pianoAudioLoadTime');
                
                // å¦‚æœç¼“å­˜å­˜åœ¨ä¸”æ˜¯æœ€è¿‘åŠ è½½çš„ï¼ˆæ¯”å¦‚1å°æ—¶å†…ï¼‰ï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜
                if (cachedAudioData && cachedLoadTime && (Date.now() - parseInt(cachedLoadTime)) < 3600000) {
                    try {
                        console.log("ä»sessionStorageåŠ è½½ç¼“å­˜çš„éŸ³æºæ•°æ®");
                        updateLoadProgress(50, "ä»ç¼“å­˜åŠ è½½éŸ³æºé…ç½®...");
                        
                        const audioData = JSON.parse(cachedAudioData);
                        
                        const sampler = new Tone.Sampler({
                            urls: audioData.soundFiles,
                            baseUrl: audioData.baseUrl,
                            onload: () => {
                                console.log("ä»ç¼“å­˜åŠ è½½éŸ³æºå®Œæˆ");
                                updateLoadProgress(100, "éŸ³æºåŠ è½½å®Œæˆï¼");
                                isAudioLoaded = true;
                                globalSampler = sampler;
                                
                                // å»¶è¿Ÿéšè—åŠ è½½ç•Œé¢ï¼Œè®©ç”¨æˆ·çœ‹åˆ°å®Œæˆä¿¡æ¯
                                setTimeout(() => {
                                    hideLoadingPage();
                                    resolve(sampler);
                                }, 500);
                            },
                            onerror: (error) => {
                                console.error("ç¼“å­˜éŸ³æºåŠ è½½å¤±è´¥ï¼Œé‡æ–°åŠ è½½:", error);
                                updateLoadProgress(0, "ç¼“å­˜åŠ è½½å¤±è´¥ï¼Œé‡æ–°åŠ è½½...");
                                // ç¼“å­˜åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æ­£å¸¸åŠ è½½æµç¨‹
                                loadAudioFromScratch(resolve, reject);
                            }
                        }).toDestination();
                        
                        return;
                    } catch (error) {
                        console.error("ç¼“å­˜è§£æå¤±è´¥ï¼Œé‡æ–°åŠ è½½éŸ³æº:", error);
                        updateLoadProgress(0, "ç¼“å­˜è§£æå¤±è´¥ï¼Œé‡æ–°åŠ è½½...");
                        // å¦‚æœç¼“å­˜è§£æå¤±è´¥ï¼Œç»§ç»­æ­£å¸¸åŠ è½½æµç¨‹
                        loadAudioFromScratch(resolve, reject);
                    }
                } else {
                    // æ²¡æœ‰ç¼“å­˜ï¼Œæ­£å¸¸åŠ è½½
                    updateLoadProgress(0, "æ²¡æœ‰ç¼“å­˜ï¼Œå¼€å§‹ä»æœ¬åœ°åŠ è½½éŸ³æº...");
                    loadAudioFromScratch(resolve, reject);
                }
            });
        }

        // æ­£å¸¸åŠ è½½éŸ³æºçš„å‡½æ•°
        function loadAudioFromScratch(resolve, reject) {
            console.log("å¼€å§‹åŠ è½½éŸ³æº...");
            
            // å¼€å§‹æ¨¡æ‹ŸåŠ è½½è¿›åº¦
            simulateLoadProgress();
            
            const sampler = new Tone.Sampler({
                urls: soundFiles,
                baseUrl: "./sounds/",
                onload: () => {
                    console.log("æœ¬åœ°é’¢ç´éŸ³æºåŠ è½½å®Œæˆ");
                    updateLoadProgress(100, "éŸ³æºåŠ è½½å®Œæˆï¼");
                    isAudioLoaded = true;
                    globalSampler = sampler;
                    
                    // å°†éŸ³æºæ•°æ®å­˜å‚¨åˆ°sessionStorageä¾›ä¸‹æ¬¡ä½¿ç”¨
                    try {
                        const audioData = {
                            soundFiles: soundFiles,
                            baseUrl: "./sounds/",
                            loadTime: Date.now()
                        };
                        sessionStorage.setItem('pianoAudioData', JSON.stringify(audioData));
                        sessionStorage.setItem('pianoAudioLoadTime', Date.now().toString());
                        console.log("éŸ³æºæ•°æ®å·²å­˜å‚¨åˆ°sessionStorage");
                    } catch (error) {
                        console.warn("sessionStorageå­˜å‚¨å¤±è´¥:", error);
                    }
                    
                    // å»¶è¿Ÿéšè—åŠ è½½ç•Œé¢ï¼Œè®©ç”¨æˆ·çœ‹åˆ°å®Œæˆä¿¡æ¯
                    setTimeout(() => {
                        hideLoadingPage();
                        resolve(sampler);
                    }, 500);
                },
                onerror: (error) => {
                    console.error("éŸ³æºåŠ è½½é”™è¯¯:", error);
                    updateLoadProgress(0, `åŠ è½½é”™è¯¯: ${error.message}`);
                }
            }).toDestination();
        }

        // pure-piano.js ç®€åŒ–ç‰ˆ
        const octaveStart = 0; // ä»A0å¼€å§‹
        const octaveEnd = 8;   // åˆ°C8ç»“æŸ
        const blackKeys = ["C#", "D#", "F#", "G#", "A#"];

        let noteDuration = 0.8;

        // åˆ›å»ºé’¢ç´é”®ç›˜
        function createPiano(pianoElement) {
            if (!pianoElement) return;

            pianoElement.innerHTML = '';

            for (let octave = octaveStart; octave <= octaveEnd; octave++) {
                let startIndex = 0;
                let endIndex = 11;

                if (octave === 0) {
                    startIndex = 9;
                    endIndex = 11;
                } else if (octave === 8) {
                    startIndex = 0;
                    endIndex = 0;
                }

                const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

                for (let i = startIndex; i <= endIndex; i++) {
                    const note = notes[i];
                    const fullNote = note + octave;
                    const isBlack = blackKeys.includes(note);

                    const key = document.createElement('div');
                    key.className = `key ${isBlack ? 'black' : 'white'}`;
                    key.dataset.note = fullNote;

                    const label = document.createElement('div');
                    label.className = 'key-label';
                    label.textContent = fullNote;
                    key.appendChild(label);

                    // ç‚¹å‡»ç´é”®äº‹ä»¶
                    key.addEventListener('click', async () => {
                        try {
                            if (Tone.context.state !== 'running') {
                                await Tone.start();
                            }

                            key.classList.add('playing');
                            setTimeout(() => key.classList.remove('playing'), 300);
                            globalSampler.triggerAttackRelease(fullNote, noteDuration);
                        } catch (error) {
                            console.error("æ’­æ”¾é”™è¯¯:", error);
                        }
                    });

                    // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
                    key.addEventListener('touchstart', async (e) => {
                        e.preventDefault();
                        try {
                            if (Tone.context.state !== 'running') {
                                await Tone.start();
                            }

                            key.classList.add('playing');
                            setTimeout(() => key.classList.remove('playing'), 300);
                            globalSampler.triggerAttackRelease(fullNote, noteDuration);
                        } catch (error) {
                            console.error("æ’­æ”¾é”™è¯¯:", error);
                        }
                    });

                    pianoElement.appendChild(key);
                }
            }
        }

        // æ’­æ”¾é’¢ç´éŸ³ç¬¦
        async function playNote(noteName, duration = 0.8, startTime = null) {
            try {
                await Tone.start();

                // ä¿®å¤ï¼šä½¿ç”¨ä¼ å…¥çš„startTimeè€Œä¸æ˜¯Tone.now()
                const now = startTime !== null ? startTime : Tone.now();
                globalSampler.triggerAttackRelease(noteName, duration, now);

                // é«˜äº®ç´é”®
                const key = document.querySelector(`.fullscreen-piano-keyboard .key[data-note="${noteName}"]`);
                if (key) {
                    key.classList.add('playing');
                    setTimeout(() => {
                        key.classList.remove('playing');
                    }, duration * 1000);
                }

            } catch (error) {
                console.error("æ’­æ”¾éŸ³ç¬¦é”™è¯¯:", error);
            }
        }

        // é’¢ç´æ’­æ”¾å™¨
        class PianoPlayer {
            constructor(sampler) {
                this.isPlaying = false;
                this.currentTimeIndex = 0;
                this.playbackSchedule = null;
                this.scheduledEvents = [];
                this.pausedTime = 0;
                this.isPaused = false;
                this.isFullscreen = false;
                this.rainContainer = null;
                this.activeRainElements = [];
                this.noteBaseDuration = 1;
                this.noteBaseVelocity = 1;
                this.rainDefaultSpeed = 3;
                this.sampler = sampler;

                // é’¢ç´é›¨é¢œè‰²æ˜ å°„
                this.baseNoteColors = {
                    'C4': 'hsl(0, 80%, 60%)',
                    'C#4': 'hsl(30, 80%, 60%)',
                    'D4': 'hsl(60, 80%, 60%)',
                    'D#4': 'hsl(90, 80%, 60%)',
                    'E4': 'hsl(120, 80%, 60%)',
                    'F4': 'hsl(150, 80%, 60%)',
                    'F#4': 'hsl(180, 80%, 60%)',
                    'G4': 'hsl(210, 80%, 60%)',
                    'G#4': 'hsl(240, 80%, 60%)',
                    'A4': 'hsl(270, 80%, 60%)',
                    'A#4': 'hsl(300, 80%, 60%)',
                    'B4': 'hsl(330, 80%, 60%)'
                };

                this.initUI();
                this.setupEventListeners();
            }

            initUI() {
                this.fullscreenPiano = document.getElementById('fullscreenPiano');
                this.fullscreenPianoKeyboard = document.getElementById('fullscreenPianoKeyboard');
                this.fullscreenPlaybackInfo = document.getElementById('fullscreenPlaybackInfo');
                this.collapseBtn = document.getElementById('collapsePiano');

                this.initPiano();
                this.createRainContainer();
            }

            setupEventListeners() {
                // ä¸»é¡µé¢æŒ‰é’®
                document.getElementById('showPianoBtn').addEventListener('click', () => this.showFullscreenPiano());

                // æ”¶èµ·æŒ‰é’®
                this.collapseBtn.addEventListener('click', () => this.collapseFullscreen());

                // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è°ƒæ•´é’¢ç´å¤§å°
                window.addEventListener('resize', () => {
                    if (this.isFullscreen) {
                        setTimeout(() => this.adjustPianoSize(), 100);
                    }
                });
            }

            createRainContainer() {
                this.rainContainer = document.createElement('div');
                this.rainContainer.className = 'piano-rain-container';
                this.fullscreenPiano.appendChild(this.rainContainer);
            }

            initPiano() {
                createPiano(this.fullscreenPianoKeyboard);
            }

            showFullscreenPiano() {
                this.isFullscreen = true;

                document.body.classList.add('fullscreen-mode');
                this.fullscreenPiano.classList.add('active');

                setTimeout(() => {
                    this.adjustPianoSize();
                }, 100);
            }

            collapseFullscreen() {
                this.isFullscreen = false;
                document.body.classList.remove('fullscreen-mode');
                this.fullscreenPiano.classList.remove('active');
                this.stop();
            }

            adjustPianoSize() {
                if (!this.isFullscreen) return;

                const keyboard = this.fullscreenPianoKeyboard;
                const container = keyboard.parentElement;
                const containerWidth = container.clientWidth;

                const whiteKeys = keyboard.querySelectorAll('.white.key');
                if (whiteKeys.length === 0) return;

                const totalWhiteKeys = whiteKeys.length;
                const newWhiteKeyWidth = Math.max(20, Math.floor(containerWidth / totalWhiteKeys));

                whiteKeys.forEach(key => {
                    key.style.width = `${newWhiteKeyWidth}px`;
                    key.style.minWidth = `${newWhiteKeyWidth}px`;
                });

                const blackKeys = keyboard.querySelectorAll('.black.key');
                const newBlackKeyWidth = Math.max(12, Math.floor(newWhiteKeyWidth * 0.6));

                blackKeys.forEach(key => {
                    key.style.width = `${newBlackKeyWidth}px`;
                    key.style.minWidth = `${newBlackKeyWidth}px`;
                    key.style.marginLeft = `-${newBlackKeyWidth / 2}px`;
                    key.style.marginRight = `-${newBlackKeyWidth / 2}px`;
                });

                const keyLabels = keyboard.querySelectorAll('.key-label');
                const newFontSize = Math.max(8, Math.floor(newWhiteKeyWidth * 0.4));
                keyLabels.forEach(label => {
                    label.style.fontSize = `${newFontSize}px`;
                });
            }

            // æ’­æ”¾å•ä¸ªéŸ³ç¬¦
            async playPianoNote(noteName, duration = 0.8, startTime = null, velocity = 1) {
                try {
                    let actualDuration = duration * this.noteBaseDuration;

                    await playNote(noteName, actualDuration, startTime);
                    this.highlightKey(noteName, actualDuration);

                    // åˆ›å»ºé’¢ç´é›¨æ•ˆæœ
                    this.createRainEffect(noteName, actualDuration);
                } catch (error) {
                    console.error("æ’­æ”¾éŸ³ç¬¦é”™è¯¯:", error);
                }
            }

            highlightKey(noteName, duration) {
                if (!this.fullscreenPianoKeyboard) return;

                const key = this.fullscreenPianoKeyboard.querySelector(`.key[data-note="${noteName}"]`);
                if (key) {
                    key.classList.add('playing');
                    setTimeout(() => {
                        key.classList.remove('playing');
                    }, duration * 1000);
                }
            }

            // åŒæ—¶æ’­æ”¾å¤šä¸ªéŸ³ç¬¦
            async playNotesSimultaneously(notes, startTime = null) {
                if (!notes || notes.length === 0) return;

                try {
                    if (Tone.context.state !== 'running') {
                        await Tone.start();
                    }

                    // ä¿®å¤ï¼šä½¿ç”¨ä¼ å…¥çš„startTimeè€Œä¸æ˜¯Tone.now()
                    const actualStartTime = startTime !== null ? startTime : Tone.now() + 0.1;

                    const playPromises = notes.map(note => {
                        let duration = Math.min(note.duration || 0.8, 2);
                        const velocity = note.velocity || 1;

                        this.createRainEffect(note.note || note, duration, note);

                        return this.playPianoNote(note.note || note, duration, actualStartTime, velocity);
                    });

                    await Promise.all(playPromises);

                } catch (error) {
                    console.error("æ’­æ”¾å’Œå¼¦é”™è¯¯:", error);
                }
            }

            getNoteColor(noteName) {
                const match = noteName.match(/([A-Ga-g]#?b?)(\d+)/);
                if (!match) return 'hsl(0, 80%, 60%)';

                const pitch = match[1];
                const octave = parseInt(match[2]);

                const baseNote = pitch + '4';
                const baseColor = this.baseNoteColors[baseNote] || 'hsl(0, 80%, 60%)';

                const hslMatch = baseColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (!hslMatch) return baseColor;

                const hue = parseInt(hslMatch[1]);
                const saturation = parseInt(hslMatch[2]);
                let lightness = parseInt(hslMatch[3]);

                const octaveDiff = octave - 4;
                lightness = Math.max(10, Math.min(90, lightness + (octaveDiff * 10)));

                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            }

            createRainEffect(noteName, duration, note) {
                if (!this.rainContainer || !this.fullscreenPianoKeyboard) return;

                const key = this.fullscreenPianoKeyboard.querySelector(`.key[data-note="${noteName}"]`);
                if (!key) return;

                const keyRect = key.getBoundingClientRect();
                const containerRect = this.fullscreenPiano.getBoundingClientRect();

                const rainElement = document.createElement('div');
                rainElement.className = 'piano-rain';

                const color = this.getNoteColor(noteName);

                const minHeight = 20;
                const maxHeight = 500;
                const baseHeight = duration * 100 * this.noteBaseDuration;
                const maxHeightValue = Math.min(maxHeight, Math.max(minHeight, baseHeight));

                const moveSpeed = this.rainDefaultSpeed * 100;

                const startTop = keyRect.top - containerRect.top;

                rainElement.style.cssText = `
                    position: absolute;
                    left: ${keyRect.left - containerRect.left}px;
                    top: ${startTop}px;
                    width: ${keyRect.width}px;
                    height: 0;
                    background: linear-gradient(to top, ${color}, ${color}00);
                    border-radius: 2px;
                    z-index: 5;
                    overflow: hidden;
                    transform-origin: bottom center;
                `;

                this.rainContainer.appendChild(rainElement);

                const rainData = {
                    element: rainElement,
                    note: note,
                    duration: duration,
                    startTime: Date.now(),
                    maxHeight: maxHeightValue,
                    moveSpeed: moveSpeed,
                    startTop: startTop,
                    containerHeight: containerRect.height,
                    keyRect: keyRect,
                    containerRect: containerRect,
                    isGrowing: true,
                    currentHeight: 0
                };

                this.activeRainElements.push(rainData);
                this.startRainMovement(rainData);
            }

            startRainMovement(rainData) {
                const startTime = Date.now();
                const growDuration = rainData.duration * 1000;

                const totalMoveDistance = rainData.containerHeight + rainData.maxHeight;
                const totalMoveTime = (totalMoveDistance / rainData.moveSpeed) * 1000;

                const animate = () => {
                    if (!rainData.element.parentNode) return;

                    const elapsed = Date.now() - startTime;

                    if (elapsed <= growDuration && rainData.isGrowing) {
                        const growProgress = elapsed / growDuration;
                        const currentHeight = growProgress * rainData.maxHeight;

                        rainData.element.style.height = `${currentHeight}px`;
                        rainData.element.style.top = `${rainData.startTop - currentHeight}px`;

                        rainData.currentHeight = currentHeight;

                    } else if (rainData.isGrowing) {
                        rainData.isGrowing = false;
                        rainData.growEndTime = Date.now();
                        rainData.finalHeight = rainData.currentHeight;
                        rainData.growEndTop = parseFloat(rainData.element.style.top) || rainData.startTop;
                    }

                    if (!rainData.isGrowing) {
                        const moveElapsed = Date.now() - rainData.growEndTime;
                        const moveDistance = (moveElapsed / 1000) * rainData.moveSpeed;

                        rainData.element.style.top = `${rainData.growEndTop - moveDistance}px`;
                        rainData.element.style.height = `${rainData.finalHeight}px`;
                    }

                    const currentTop = parseFloat(rainData.element.style.top) || rainData.startTop;
                    if (currentTop > -rainData.maxHeight && elapsed < (growDuration + totalMoveTime)) {
                        requestAnimationFrame(animate);
                    } else {
                        if (rainData.element.parentNode) {
                            rainData.element.parentNode.removeChild(rainData.element);
                        }
                        const index = this.activeRainElements.indexOf(rainData);
                        if (index > -1) {
                            this.activeRainElements.splice(index, 1);
                        }
                    }
                };

                requestAnimationFrame(animate);
            }

            clearRainEffects() {
                if (this.rainContainer) {
                    this.rainContainer.innerHTML = '';
                }
                this.activeRainElements = [];
            }

            clearKeyboardHighlights() {
                if (!this.fullscreenPianoKeyboard) return;
                const keys = this.fullscreenPianoKeyboard.querySelectorAll('.key.playing');
                keys.forEach(key => {
                    key.classList.remove('playing');
                });
            }

            // æ’­æ”¾åºåˆ—ï¼ˆä¾›å¤–éƒ¨è°ƒç”¨ï¼‰
            playSequence(sequence, title = "è‡ªå®šä¹‰åºåˆ—") {
                if (!this.isFullscreen) {
                    this.showFullscreenPiano();
                    setTimeout(() => {
                        this.startPlayback(sequence, title);
                    }, 500);
                } else {
                    this.startPlayback(sequence, title);
                }
            }

            startPlayback(sequence, title) {
                if (this.isPlaying && !this.isPaused) return;

                if (this.isPaused) {
                    this.resumePlayback();
                    return;
                }

                this.isPlaying = true;
                this.isPaused = false;
                this.currentTimeIndex = 0;
                this.pausedTime = 0;

                if (this.playbackSchedule) {
                    this.playbackSchedule.stop();
                    this.playbackSchedule = null;
                }

                if (this.scheduledEvents.length) {
                    this.scheduledEvents.forEach(id => Tone.Transport.clear(id));
                    this.scheduledEvents = [];
                }

                this.clearRainEffects();
                this.clearKeyboardHighlights();

                // æŒ‰æ—¶é—´åˆ†ç»„éŸ³ç¬¦
                const timeGroups = this.groupNotesByTime(sequence);

                timeGroups.forEach((group, index) => {
                    const eventId = Tone.Transport.schedule((time) => {
                        if (!this.isPlaying) return;

                        if (group.notes.length > 1) {
                            // æ’­æ”¾å’Œå¼¦ - ä¿®å¤ï¼šä½¿ç”¨ä¼ å…¥çš„timeå‚æ•°
                            this.playNotesSimultaneously(group.notes, time);
                        } else {
                            // æ’­æ”¾å•éŸ³ - ä¿®å¤ï¼šä½¿ç”¨ä¼ å…¥çš„timeå‚æ•°
                            this.playPianoNote(group.notes[0].note || group.notes[0],
                                group.duration || 0.8, time);
                        }

                        this.currentTimeIndex = index;
                        this.updatePlaybackInfo(index, timeGroups.length, title);

                    }, group.time);
                    this.scheduledEvents.push(eventId);
                });

                const totalDuration = sequence.length > 0 ? 
                    sequence[sequence.length - 1].time + (sequence[sequence.length - 1].duration || 0.8) + 0.5 : 0;
                    
                const endEventId = Tone.Transport.schedule(() => {
                    this.stop();
                }, totalDuration);
                this.scheduledEvents.push(endEventId);

                Tone.Transport.start();
                this.playbackStartTime = Tone.now();
                this.updatePlaybackInfo(0, timeGroups.length, title);
            }

            // æŒ‰æ—¶é—´åˆ†ç»„éŸ³ç¬¦
            groupNotesByTime(notes) {
                if (notes.length === 0) return [];

                const validNotes = notes.filter(note => note && (note.time !== undefined || note.note));
                if (validNotes.length === 0) return [];

                // ä¸ºæ¯ä¸ªéŸ³ç¬¦æ·»åŠ æ—¶é—´å±æ€§ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                validNotes.forEach((note, index) => {
                    if (note.time === undefined) {
                        note.time = index * 0.5; // é»˜è®¤0.5ç§’é—´éš”
                    }
                });

                // æŒ‰æ—¶é—´æ’åº
                validNotes.sort((a, b) => (a.time || 0) - (b.time || 0));

                const groups = [];
                let currentGroup = {
                    time: validNotes[0].time,
                    notes: [validNotes[0]],
                    duration: validNotes[0].duration || 0.8
                };

                for (let i = 1; i < validNotes.length; i++) {
                    const note = validNotes[i];
                    if (!note) continue;

                    if (Math.abs(note.time - currentGroup.time) < 0.001) {
                        currentGroup.notes.push(note);
                        // å–æœ€é•¿çš„æŒç»­æ—¶é—´
                        if (note.duration && note.duration > currentGroup.duration) {
                            currentGroup.duration = note.duration;
                        }
                    } else {
                        groups.push(currentGroup);
                        currentGroup = {
                            time: note.time,
                            notes: [note],
                            duration: note.duration || 0.8
                        };
                    }
                }

                groups.push(currentGroup);
                return groups;
            }

            updatePlaybackInfo(currentIndex, totalItems, title) {
                this.fullscreenPlaybackInfo.textContent =
                    `æ’­æ”¾ä¸­: ${title} (${currentIndex + 1}/${totalItems})`;
            }

            resumePlayback() {
                if (!this.isPaused) return;

                this.isPlaying = true;
                this.isPaused = false;
                Tone.Transport.start();
            }

            pausePlayback() {
                if (Tone.Transport.state === 'started') {
                    Tone.Transport.pause();
                    this.isPlaying = false;
                    this.isPaused = true;
                    this.pausedTime = Tone.Transport.seconds;

                    if (this.scheduledEvents.length) {
                        this.scheduledEvents.forEach(id => Tone.Transport.clear(id));
                        this.scheduledEvents = [];
                    }
                }
            }

            stop() {
                if (this.playbackSchedule) {
                    this.playbackSchedule.stop();
                    this.playbackSchedule = null;
                }

                Tone.Transport.stop();
                Tone.Transport.cancel();

                if (this.scheduledEvents.length) {
                    this.scheduledEvents.forEach(id => Tone.Transport.clear(id));
                    this.scheduledEvents = [];
                }

                this.isPlaying = false;
                this.isPaused = false;
                this.currentTimeIndex = 0;
                this.pausedTime = 0;
                this.clearKeyboardHighlights();
                this.clearRainEffects();

                this.fullscreenPlaybackInfo.textContent = `æ’­æ”¾å·²åœæ­¢`;
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', function () {
            // å…ˆåŠ è½½éŸ³æº
            initAudioLoad().then((sampler) => {
                // éŸ³æºåŠ è½½å®Œæˆååˆå§‹åŒ–é’¢ç´æ’­æ”¾å™¨
                window.pianoPlayer = new PianoPlayer(sampler);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ä»ear.htmlä¼ é€’çš„è½¬æ¢åºåˆ—
                function checkAndPlayConvertedSequence() {
                    const convertedSequence = sessionStorage.getItem('convertedAbsoluteSequence');
                    const defaultNoteDuration = sessionStorage.getItem('defaultNoteDuration');
                    const defaultNoteVelocity = sessionStorage.getItem('defaultNoteVelocity');
                    const infoElement = document.getElementById('conversionInfo');

                    if (convertedSequence) {
                        if (infoElement) {
                            infoElement.innerHTML = `æ£€æµ‹åˆ°è½¬æ¢åºåˆ—<br>æ­£åœ¨å‡†å¤‡æ’­æ”¾...`;
                        }

                        // è®¾ç½®é»˜è®¤å‚æ•°
                        if (defaultNoteDuration) {
                            window.pianoPlayer.noteBaseDuration = parseFloat(defaultNoteDuration);
                        }
                        if (defaultNoteVelocity) {
                            window.pianoPlayer.noteBaseVelocity = parseFloat(defaultNoteVelocity);
                        }

                        // è§£æå¹¶æ’­æ”¾åºåˆ—
                        const parsedSequence = parseConvertedSequence(convertedSequence);
                        if (parsedSequence && parsedSequence.length > 0) {
                            // å»¶è¿Ÿä¸€ä¸‹ç¡®ä¿é’¢ç´ç•Œé¢å®Œå…¨åŠ è½½
                            setTimeout(() => {
                                window.pianoPlayer.playSequence(parsedSequence, "ç‰¹æ•ˆç‚¹æ’­åºåˆ—");
                                // æ’­æ”¾å®Œæˆåæ¸…ç†sessionStorage
                                sessionStorage.removeItem('convertedAbsoluteSequence');
                                sessionStorage.removeItem('defaultNoteDuration');
                                sessionStorage.removeItem('defaultNoteVelocity');
                            }, 1000);
                        }
                    } else {
                        if (infoElement) {
                            infoElement.innerHTML = "è¿™æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å…¨å±é’¢ç´é¡µé¢ï¼ŒåŒ…å«é’¢ç´é›¨æ•ˆæœï¼Œå¯ä»¥æ‰‹åŠ¨å¼¹å¥æˆ–é€šè¿‡APIè°ƒç”¨æ’­æ”¾åŠŸèƒ½ã€‚";
                        }
                    }
                }

                // è§£æè½¬æ¢åçš„åºåˆ—
                function parseConvertedSequence(sequenceStr) {
                    try {
                        const items = sequenceStr.split(',').map(item => item.trim()).filter(item => item);
                        const sequence = [];
                        let currentTime = 0;

                        items.forEach((item, index) => {
                            // å¤„ç†ä¼‘æ­¢ç¬¦ï¼ˆä»¥ä¸‹åˆ’çº¿å¼€å¤´ï¼‰
                            if (item.startsWith('_')) {
                                const restParts = item.substring(1).split('_').filter(part => part);
                                let restDuration = window.pianoPlayer.noteBaseDuration;
                                let restSustain = 0;

                                if (restParts.length >= 1) {
                                    restDuration = parseFloat(restParts[0]) || restDuration;
                                }
                                if (restParts.length >= 2) {
                                    restSustain = parseFloat(restParts[1]) || 0;
                                }

                                // ä¼‘æ­¢ç¬¦ï¼šå¢åŠ æ—¶é—´ä½†ä¸æ·»åŠ éŸ³ç¬¦
                                currentTime += restDuration;
                                return;
                            }

                            // å¤„ç†å’Œå¼¦ï¼ˆæ‹¬å·å†…çš„å†…å®¹ï¼‰
                            if (item.startsWith('(') && item.endsWith(')')) {
                                const chordContent = item.substring(1, item.length - 1);
                                const chordNotes = chordContent.split(',').map(note => note.trim()).filter(note => note);
                                const chordSequence = [];

                                chordNotes.forEach(chordNote => {
                                    const noteData = parseSingleNote(chordNote, currentTime);
                                    if (noteData) {
                                        chordSequence.push(noteData);
                                    }
                                });

                                if (chordSequence.length > 0) {
                                    // å–æœ€é•¿çš„æŒç»­æ—¶é—´ä½œä¸ºå’Œå¼¦çš„æŒç»­æ—¶é—´
                                    const maxDuration = Math.max(...chordSequence.map(note => note.duration));
                                    sequence.push({
                                        time: currentTime,
                                        notes: chordSequence,
                                        duration: maxDuration,
                                        isChord: true
                                    });
                                    currentTime += maxDuration;
                                }
                                return;
                            }

                            // å¤„ç†å•ä¸ªéŸ³ç¬¦
                            const noteData = parseSingleNote(item, currentTime);
                            if (noteData) {
                                sequence.push({
                                    time: currentTime,
                                    notes: [noteData],
                                    duration: noteData.duration,
                                    isChord: false
                                });
                                currentTime += noteData.duration;
                            }
                        });

                        return sequence;
                    } catch (error) {
                        console.error("è§£æåºåˆ—é”™è¯¯:", error);
                        return null;
                    }
                }

                // è§£æå•ä¸ªéŸ³ç¬¦
                function parseSingleNote(noteStr, startTime) {
                    const parts = noteStr.split('_').filter(part => part);
                    if (parts.length === 0) return null;

                    const noteName = parts[0];
                    let duration = window.pianoPlayer.noteBaseDuration;
                    let velocity = window.pianoPlayer.noteBaseVelocity;
                    let sustain = 0;

                    // è§£ææ—¶é•¿
                    if (parts.length >= 2) {
                        duration = parseFloat(parts[1]) || duration;
                    }

                    // è§£æåŠ›åº¦
                    if (parts.length >= 3) {
                        velocity = parseFloat(parts[2]) || velocity;
                    }

                    // è§£æå»¶éŸ³
                    if (parts.length >= 4) {
                        sustain = parseFloat(parts[3]) || 0;
                    }

                    return {
                        note: noteName,
                        duration: duration,
                        velocity: velocity,
                        sustain: sustain,
                        time: startTime
                    };
                }

                // ä¿®æ”¹PianoPlayerç±»çš„playSequenceæ–¹æ³•ï¼Œæ”¯æŒæ–°çš„åºåˆ—æ ¼å¼
                PianoPlayer.prototype.playSequence = function (sequence, title = "è‡ªå®šä¹‰åºåˆ—") {
                    if (!this.isFullscreen) {
                        this.showFullscreenPiano();
                        setTimeout(() => {
                            this.startPlayback(sequence, title);
                        }, 500);
                    } else {
                        this.startPlayback(sequence, title);
                    }
                };

                // ä¿®æ”¹startPlaybackæ–¹æ³•ä»¥æ”¯æŒæ–°çš„åºåˆ—æ ¼å¼
                PianoPlayer.prototype.startPlayback = function (sequence, title) {
                    if (this.isPlaying && !this.isPaused) return;

                    if (this.isPaused) {
                        this.resumePlayback();
                        return;
                    }

                    this.isPlaying = true;
                    this.isPaused = false;
                    this.currentTimeIndex = 0;
                    this.pausedTime = 0;

                    if (this.playbackSchedule) {
                        this.playbackSchedule.stop();
                        this.playbackSchedule = null;
                    }

                    if (this.scheduledEvents.length) {
                        this.scheduledEvents.forEach(id => Tone.Transport.clear(id));
                        this.scheduledEvents = [];
                    }

                    this.clearRainEffects();
                    this.clearKeyboardHighlights();

                    // å®‰æ’æ’­æ”¾äº‹ä»¶
                    sequence.forEach((item, index) => {
                        const eventId = Tone.Transport.schedule((time) => {
                            if (!this.isPlaying) return;

                            if (item.isChord && item.notes) {
                                // æ’­æ”¾å’Œå¼¦ - ä¿®å¤ï¼šä½¿ç”¨ä¼ å…¥çš„timeå‚æ•°
                                this.playNotesSimultaneously(item.notes, time);
                            } else if (item.notes && item.notes.length > 0) {
                                // æ’­æ”¾å•éŸ³ - ä¿®å¤ï¼šä½¿ç”¨ä¼ å…¥çš„timeå‚æ•°
                                const note = item.notes[0];
                                this.playPianoNote(note.note, note.duration, time, note.velocity);
                            }

                            this.currentTimeIndex = index;
                            this.updatePlaybackInfo(index, sequence.length, title);

                        }, item.time);
                        this.scheduledEvents.push(eventId);
                    });

                    const totalDuration = sequence.length > 0 ?
                        sequence[sequence.length - 1].time + sequence[sequence.length - 1].duration + 0.5 : 0;

                    const endEventId = Tone.Transport.schedule(() => {
                        this.stop();
                    }, totalDuration);
                    this.scheduledEvents.push(endEventId);

                    Tone.Transport.start();
                    this.playbackStartTime = Tone.now();
                    this.updatePlaybackInfo(0, sequence.length, title);
                };

                // ä¿®æ”¹playNotesSimultaneouslyæ–¹æ³•ä»¥æ”¯æŒæ–°çš„éŸ³ç¬¦æ ¼å¼
                PianoPlayer.prototype.playNotesSimultaneously = async function (notes, startTime = null) {
                    if (!notes || notes.length === 0) return;

                    try {
                        if (Tone.context.state !== 'running') {
                            await Tone.start();
                        }

                        // ä¿®å¤ï¼šä½¿ç”¨ä¼ å…¥çš„startTimeè€Œä¸æ˜¯Tone.now()
                        const actualStartTime = startTime !== null ? startTime : Tone.now() + 0.1;
                        const playPromises = notes.map(note => {
                            let duration = Math.min(note.duration || 0.8, 2);
                            const velocity = note.velocity || 1;

                            this.createRainEffect(note.note, duration, note);
                            return this.playPianoNote(note.note, duration, actualStartTime, velocity);
                        });

                        await Promise.all(playPromises);
                    } catch (error) {
                        console.error("æ’­æ”¾å’Œå¼¦é”™è¯¯:", error);
                    }
                };

                // é¡µé¢åŠ è½½å®Œæˆåæ£€æŸ¥å¹¶æ’­æ”¾åºåˆ—
                setTimeout(() => {
                    checkAndPlayConvertedSequence();
                }, 500);

            }).catch((error) => {
                console.error("éŸ³æºåŠ è½½å¤±è´¥:", error);
                // å³ä½¿éŸ³æºåŠ è½½å¤±è´¥ï¼Œä¹Ÿæ˜¾ç¤ºä¸»ç•Œé¢
                hideLoadingPage();
                document.querySelector('.container').style.display = 'block';
                document.getElementById('conversionInfo').innerHTML = 
                    "éŸ³æºåŠ è½½å¤±è´¥ï¼Œé’¢ç´åŠŸèƒ½å¯èƒ½æ— æ³•æ­£å¸¸ä½¿ç”¨ã€‚è¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚";
            });
        });
    </script>
</body>

</html>